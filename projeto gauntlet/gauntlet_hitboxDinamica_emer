.include "MACROSv21.s"

.data
menu:
.include "menu_gauntlet.data"
mapa_e_hitbox:
.include "mapa1_teste.data"
.include "hitbox_mapateste2.data"
.include "GauntletRoom001MapBG.data"
.include "escotilha_aberta.data"
.include "tile.data"
.include "tile1.data"
.include "tile2.data"
.include "tile_hitbox_char.data"
lamar:
.include "lamar_cima.data"
.include "lamar_baixo.data"
.include "lamar_direita.data"
.include "lamar_esquerda.data"
ataqueLamar: 
.include "memoria_ram.data"

ULT_TECL:       .asciz "W"                      # Ultimo caracter pressionado
CHAR_POS:	.half 8,8			# x, y
OLD_CHAR_POS:	.half 8,8			# x, y
SAIDA_POS: 	.half 8,216			# x, y
ULT_PROJ: 	.half 0, 0                      # x, y do projetil
PROJATUAL:      .half 0, 0                      #X, Y atual do projetil
ULTMOV:         .byte -1                        #Guarda o ultimo movimento do projetil

.text
#OBSERVAÇÕES:
#*No menu, a opção de ver as instruções ainda não está implementada, nada acontecerá se você pressionar 2
#*Recomenda-se o uso do paint.net com o arquivo da hitbox ou do mapa para obter as coordenadas precisas de onde você quer printar
#ou de qual pixel você quer checar
#*Cuidado com as coordenadas que utilizará, se não forem múltiplas de 4, muito provavelmente dará erro
#*Na seleção de mapas o mapa2 está igual o primeiro apenas como placeholder, a implementação de um mapa diferente é fácil

##########
##########
MENU:
	la a0, menu_gauntlet		# Carrega o endereço do menu para printá-lo apenas no frame 0
	li a1,0				# x = 0
	li a2,0				# y = 0
	li a3,0				# frame = 0
	call print			# imprime o sprite
	
	call KEY1
	
KEY1: 	li t1,0xFF200000		# carrega o endereço de controle do KDMMIO
LOOP: 	lw t0,0(t1)			# Le bit de Controle Teclado
   	andi t0,t0,0x0001		# mascara o bit menos significativo
   	beq t0,zero,LOOP		# não tem tecla pressionada então volta ao loop
   	lw t2,4(t1)			# le o valor da tecla
  	sw t2,12(t1)  			# escreve a tecla pressionada no display
  	
  	li t0,'1'
  	beq t2,t0,SETUP
  	
  	li t0,'3'
  	beq t2,t0,sair
  	
  	ret				# retorna 
##########
##########	
SETUP:	
#Seleciona-se o mapa com base no valor de S10
	beq s10,zero,map1	
	li t0,1
	beq s10,t0,map2

map1:	la a0,mapa1_teste
	j setup1
map2:	la a0,mapa1_teste
	j setup1
#Printa o mapa selecionado no frame 0
setup1:	li a1,0				# x = 0
	li a2,0				# y = 0
	li a3,0				# frame = 0
	call print			# imprime o sprite	
#Seleciona-se a hitbox correspondente com base no S10
	beq s10,zero,hitbox1
	li t0,1
	beq s10,t0,hitbox2	
	
hitbox1:
	la a0,hitbox_mapateste2
	j setup2
hitbox2:
	la a0,hitbox_mapateste2
	j setup2
#Printa a hitbox selecionada no frame 1		
setup2:	li a1,0				# x = 0
	li a2,0				# y = 0	
	li a3,1				# frame = 1
	call print			# imprime o sprite

 	la s3,lamar_baixo		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)
 	
 	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	la a0,tile_hitbox_char		# Carrega o endereço da hitbox do personagem
	li a3,1				# Seleciona o frame 1
	call print			# imprime o sprite
	
	
 	li s11,0			# Define o valor inicial do registrador da chave
##########
##########
CHECK_KEY:
	beq s11,zero,GAME_LOOP
	la t0,SAIDA_POS
	la a0,escotilha_aberta		# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	mv a3,s0			# carrega o valor do frame em a3
	call print
	addi s10,s10,1			# Soma-se 1 ao registrador de selecionar o mapa para indicar que o próxima mapa com sua hitbox deve ser selecionado
	li t1,8				# Soma-se 8 para resetar a posição inicial do personagem e sua hitbox(Supõe-se que a posição inicial do personagem será nas coordenadas (8,8) em todos os mapas por via de simplicidade)
	la t0,CHAR_POS			# Carrega a posição do personagem 
	sh t1,0(t0)			# Atualiza o x
	sh t1,2(t0)			# Atualiza o y
	la t0,OLD_CHAR_POS		# Carrega a posição antiga do personagem
	sh t1,0(t0)			# Atualiza o x
	sh t1,2(t0)			# Atualiza o y
	j SETUP
CHAVE:
	li s11,1			# Altera o valor do registrador da chave
######
#Realiza o processo de atualização de sprites de uma forma meio grosseira a fim de permitir o reuso para todos as direções de movimento	
	la a0,tile_hitbox_char		
	li a3,1
	call print			# imprime o sprite
	
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
#####	
	j GAME_LOOP

GAME_LOOP:
#Após as alterações feitas para acomodar a hitbox dinâmica, o game loop está vazio e , acredito eu, poderemos
#usá-lo para fazer o tempo, inimigos e outros processos que devem ocorrer sem o input do jogador
	li t5, 1
	beq s7, t5 loopTiro
		
game_loop1:
#Essa label ficará aqui por possíveis conveniências futuras, mas muito provavelmente pode ser apagada, então dane-se
	call KEY2			# chama o procedimento de entrada do teclado
		
	j GAME_LOOP
##########
##########
### Apenas verifica se há tecla pressionada
KEY2:	li t1,0xFF200000		# carrega o endereco de controle do KDMMIO
	lw t0,0(t1)			# Le bit de Controle Teclado
	andi t0,t0,0x0001		# mascara o bit menos significativo
   	beq t0,zero,FIM   	   	# Se nao ha tecla pressionada entao vai para FIM
  	lw t2,4(t1)  			# le o valor da tecla tecla
	
	li t0,'w'
	beq t2,t0,CHAR_UP		# se tecla pressionada for 'w', chama CHAR_CIMA
	
	li t0,'a'
	beq t2,t0,CHAR_LEFT		# se tecla pressionada for 'a', chama CHAR_CIMA
	
	li t0,'s'
	beq t2,t0,CHAR_DOWN		# se tecla pressionada for 's', chama CHAR_CIMA
	
	li t0,'d'
	beq t2,t0,CHAR_RIGHT		# se tecla pressionada for 'd', chama CHAR_CIMA
	
	li t0, ' '
	beq t2, t0, ATAQUE_LAMAR       #se tecla pressionada for ' ', chama ATAQUE_LAMAR
	
FIM:	ret				# retorna
##########
##########
CHAR_UP:
	la t0, ULT_TECL
	sb t2, 0(t0)                    #Guarda a ult tecla pressionada
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	li t5,320			
	li t6,-1			
	mul t3,t6,t5		
	add t4,t4,t3			# Subtrai-se -1*320 para checar qual a cor do pixel logo acima das coordenadas do jogador
	lb t4,0(t4)			# Carrega um byte do para saber a cor do pixel
	li t5,0xffffffC8		# Checa para ver se é azul/parede
	beq t4,t5,GAME_LOOP
	li t5,0x00000038		# Checa para ver se é verde/porta/escotilha
	beq t4,t5,CHECK_KEY
	
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,2(t0)
	la s3,lamar_cima		# salva
	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)			
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########

	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
	
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_DOWN:
	la t0, ULT_TECL
	sb t2, 0(t0)                    #Guarda a ult tecla pressionada
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	li t5,320
	li t6,16
	mul t3,t6,t5
	add t4,t4,t3
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	
	la t0,CHAR_POS
	lh t1,2(t0)			# carrega o y atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,2(t0)
	la s3,lamar_baixo			# salva
		
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_LEFT:
	la t0, ULT_TECL
	sb t2, 0(t0)                    #Guarda a ult tecla pressionada	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,-1
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	addi t4,t4,-1
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,0(t0)
	la s3,lamar_esquerda			# salva
		
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	
##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_RIGHT:
	la t0, ULT_TECL
	sb t2, 0(t0)                    #Guarda a ult tecla pressionada	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,23
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	addi t4,t4,16
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,0(t0)			# salva
	la s3,lamar_direita			
		
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########	
print:
	li t0,0xFF0			# carrega 0xFF0 em t0
	add t0,t0,a3			# adiciona o frame ao FF0 (se o frame for 1 vira FF1, se for 0 fica FF0)
	slli t0,t0,20			# shift de 20 bits pra esquerda (0xFF0 vira 0xFF000000, 0xFF1 vira 0xFF100000)
	
	add t0,t0,a1			# adiciona x ao t0
	
	li t1,320			# t1 = 320
	mul t1,t1,a2			# t1 = 320 * y
	add t0,t0,t1			# adiciona t1 ao t0
	
	addi t1,a0,8			# t1 = a0 + 8
	
	mv t2,zero			# zera t2
	mv t3,zero			# zera t3
	
	lw t4,0(a0)			# carrega a largura em t4
	lw t5,4(a0)			# carrega a altura em t5
	
	
PRINT_LINHA:
	lw t6,0(t1)			# carrega em t6 uma word (4 pixeis) da imagem
	sw t6,0(t0)			# imprime no bitmap a word (4 pixeis) da imagem
	
	addi t0,t0,4			# incrementa endereco do bitmap
	addi t1,t1,4			# incrementa endereco da imagem
	
	addi t3,t3,4			# incrementa contador de coluna
	blt t3,t4,PRINT_LINHA		# se contador da coluna < largura, continue imprimindo

	addi t0,t0,320			# t0 += 320
	sub t0,t0,t4			# t0 -= largura da imagem
	# ^ isso serve pra "pular" de linha no bitmap display
	
	mv t3,zero			# zera t3 (contador de coluna)
	addi t2,t2,1			# incrementa contador de linha
	bgt t5,t2,PRINT_LINHA		# se altura > contador de linha, continue imprimindo
	
	ret				# retorna

ATAQUE_LAMAR:
	la t0, ataqueLamar
	mv a0, t0
	
	la t0, ULT_TECL
	lb t1, 0(t0)
	
	li t3, 'w'
	beq t1, t3, CIMA
	
	li t3, 'a'
	beq t1, t3, LEFT
	
	li t3, 's'
	beq t1, t3, BAIXO
	
	li t3 , 'd'
	beq t1, t3, RIGTH
CIMA:
	li t4, 0
	la t1, ULTMOV
	sb t4, 0(t1)
LEFT:
	li t4, 1
	la t1, ULTMOV
	sb t4, 0(t1)
BAIXO:
	li t4, 2
	la t1, ULTMOV
	sb t4, 0(t1)
RIGTH:
	li t4, 3
	la t1, ULTMOV
	sb t4, 0(t1)
loopTiro:
	li t3, 1
	beq s7, t3, CHECKs
	la t0, PROJATUAL
	la t1, CHAR_POS
	lh t6,0(t1)
	lh t5,2(t1)
	sh t6, 0(t0)
	sh t5, 2(t0)
	
CHECKs:
	li s7, 1                     #grava q atirou
	la t1, ULTMOV
	lb t4, 0(t1)
	
	li t3, 0
	beq t4, t3, MOV_CIMA
	
	li t3, 1
	beq t4, t3, MOV_LEFT
	
	li t3, 2
	beq t4, t3, MOV_BAIXO
	
	li t3 , 3
	beq t4, t3, MOV_RIGHT

MOV_CIMA:
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	la t1,ULT_PROJ			# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,PROJATUAL
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	li t5,320			
	li t6,-1			
	mul t3,t6,t5		
	add t4,t4,t3			# Subtrai-se -1*320 para checar qual a cor do pixel logo acima das coordenadas do jogador
	lb t4,0(t4)			# Carrega um byte do para saber a cor do pixel
	li t5,0xffffffC8		# Checa para ver se é azul/parede
	beq t4,t5,CLEANER
	li t5,0x00000038		# Checa para ver se é verde/porta/escotilha
	beq t4,t5,CLEANER             #Por enquanto volta ao game loop, mas posteriormente deverá ir para o cleaner
	
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,2(t0)
	la s3, ataqueLamar		# salva
	
	la t0,PROJATUAL		# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	ret
	
#	beq s7, x0, marker 
#	la a0, tile                
#	la t0, ULT_PROJ
#	lh a1, 0(t0)
#	lh a2, 2(t0)
#	li a3, 0
#	call print
#	j GAME_LOOP
	
MOV_LEFT:	
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	la t1,ULT_PROJ          	# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,PROJATUAL
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,-1
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	addi t4,t4,-1
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,CLEANER
	li t5,0x00000038
	beq t4,t5,CLEANER
	
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,0(t0)
	la s3, ataqueLamar			# salva
		
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	ret

MOV_BAIXO:
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	la t1,ULT_PROJ		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,PROJATUAL
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	li t5,320
	li t6,16
	mul t3,t6,t5
	add t4,t4,t3
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,CLEANER
	li t5,0x00000038
	beq t4,t5,CLEANER
	
	la t0,PROJATUAL
	lh t1,2(t0)			# carrega o y atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,2(t0)
	la s3,ataqueLamar			# salva
		
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	ret


MOV_RIGHT:	
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	la t1,ULT_PROJ		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,PROJATUAL
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,23
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	addi t4,t4,16
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,CLEANER
	li t5,0x00000038
	beq t4,t5,CLEANER
	
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,0(t0)			# salva
	la s3,ataqueLamar			
		
	la t0,PROJATUAL			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	ret
		
CLEANER:
	li s7, 0
	j GAME_LOOP
sair:
	li a7,10
	ecall

.include "SYSTEMv21.s"
