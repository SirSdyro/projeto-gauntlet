.include "MACROSv21.s"

.data
menu:
.include "menu_gauntlet.data"
.include "menu_gauntlet_2.data"
mapa_e_hitbox:
.include "mapa1_teste.data"
.include "hitbox_mapateste2.data"
.include "GauntletRoom001MapBG.data"
.include "escotilha_aberta.data"
.include "tile.data"
.include "tile1.data"
.include "tile2.data"
.include "tile_hitbox_char.data"
.include "tile_hitbox_enemy.data"
##########
##########
#PERSONAGENS#
Lamar:
.include "lamar_cima.data"
.include "lamar_baixo.data"
.include "lamar_direita.data"
.include "lamar_esquerda.data"
##########
##########
#INIMIGOS#
CapacitorParasita:
.include "capacitor_parasita.data"
.include "descarga_capacitor.data"

CHAR_POS:	.half 8,8			# x, y
OLD_CHAR_POS:	.half 8,8			# x, y
SAIDA_POS: 	.half 8,216			# x, y
TEMPO: 		.byte 60
TEMPO_ATK: 	.byte 1				# tempo até o ataque do inimigo
CHAR_SELECT:	.word 0				# define o personagem selecionado
ENEMY_1_POS:    .half 216,216			# x, y
ENEMY_1_OLD_POS:.half 216,216			# x, y
ENEMY_1_ATK:	.half 0,0			# x, y
ENEMY_1_SWITCH: .byte 1				# permite a existência do inimigo 1 (no caso o capacitor parasita)
.text
#OBSERVAÇÕES:
#*No menu, a opção de ver as instruções ainda não está implementada, nada acontecerá se você pressionar 2
#*Recomenda-se o uso do paint.net com o arquivo da hitbox ou do mapa para obter as coordenadas precisas de onde você quer printar
#ou de qual pixel você quer checar
#*Cuidado com as coordenadas que utilizará, se não forem múltiplas de 4, muito provavelmente dará erro
#*Na seleção de mapas o mapa2 está igual o primeiro apenas como placeholder, a implementação de um mapa diferente é fácil
#*O tempo só funciona no FPGrars, já que a execução detro do rars normal é lento para dedéu e lá é extremamente rápida

##########
##########
MENU:
	la a0, menu_gauntlet		# Carrega o endereço do menu para printá-lo apenas no frame 0
	li a1,0				# x = 0
	li a2,0				# y = 0
	li a3,0				# frame = 0
	call print			# imprime o sprite
	
	call KEY1
	
KEY1: 	
	li t1,0xFF200000		# carrega o endereço de controle do KDMMIO
LOOP: 	lw t0,0(t1)			# Le bit de Controle Teclado
   	andi t0,t0,0x0001		# mascara o bit menos significativo
   	beq t0,zero,LOOP		# não tem tecla pressionada então volta ao loop
   	lw t2,4(t1)			# le o valor da tecla
  	sw t2,12(t1)  			# escreve a tecla pressionada no display
  	
  	li t0,'1'
  	beq t2,t0,SELECT
  	
  	li t0,'3'
  	beq t2,t0,sair
  	
  	ret				# retorna
##########
########## 	
SELECT:
	la a0, menu_gauntlet_2		# Carrega o endereço do menu de seleção de personagem para printar apenas no frame 0
	li a1,0				# x = 0
	li a2,0				# y = 0
	li a3,0				# frame = 0
	call print			# imprime o sprite
	
	call KEY1_2
KEY1_2: 	
	li t1,0xFF200000		# carrega o endereço de controle do KDMMIO
LOOP_2: lw t0,0(t1)			# Le bit de Controle Teclado
   	andi t0,t0,0x0001		# mascara o bit menos significativo
   	beq t0,zero,LOOP_2		# não tem tecla pressionada então volta ao loop
   	lw t2,4(t1)			# le o valor da tecla
  	sw t2,12(t1)  			# escreve a tecla pressionada no display
  	
  	li t0,'1'
  	beq t2,t0,CHAR_1
 
  	li t0,'2'
  	beq t2,t0,CHAR_2
  	 	
  	li t0,'3'
  	beq t2,t0,CHAR_3
  	
  	li t0,'4'
  	beq t2,t0,CHAR_4
  	  	
 	ret				# retorna
# Os processos seguintes alteram o valor CHAR_SELECT para definir qual personagem deve ter seus sprites printados 	  	 
CHAR_1:
	li t0,'1'
	la t1,CHAR_SELECT
	sw t0,0(t1)
	j SETUP
CHAR_2:
	li t0,'2'
	la t1,CHAR_SELECT
	sw t0,0(t1)
	j SETUP	
CHAR_3:
	li t0,'3'
	la t1,CHAR_SELECT
	sw t0,0(t1)
	j SETUP	
CHAR_4:
	li t0,'4'
	la t1,CHAR_SELECT
	sw t0,0(t1)
	j SETUP	
##########
##########	
SETUP:	
#Seleciona-se o mapa com base no valor de S10
	beq s10,zero,map1	
	li t0,1
	beq s10,t0,map2

map1:	la a0,mapa1_teste
	j setup1
map2:	la a0,hitbox_mapateste2
	j setup1
#Printa o mapa selecionado no frame 0
setup1:	li a1,0				# x = 0
	li a2,0				# y = 0
	li a3,0				# frame = 0
	call print			# imprime o sprite	
#Seleciona-se a hitbox correspondente com base no S10
	beq s10,zero,hitbox1
	li t0,1
	beq s10,t0,hitbox2	
	
hitbox1:
	la a0,hitbox_mapateste2
	j setup2
hitbox2:
	la a0,hitbox_mapateste2
	j setup2
#Printa a hitbox selecionada no frame 1		
setup2:	li a1,0				# x = 0
	li a2,0				# y = 0	
	li a3,1				# frame = 1
	call print			# imprime o sprite
	
#selecionando a sprite
	la t0,CHAR_SELECT
	lw t1,0(t0)
	
  	li t0,'1'
  	beq t1,t0,psngm_1
 
  	li t0,'2'
  	beq t1,t0,psngm_2
  	 	
  	li t0,'3'
  	beq t1,t0,psngm_2
  	
  	li t0,'4'
  	beq t1,t0,psngm_2	
	

psngm_1:
 	la s3,lamar_baixo		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)	
	j setup3
psngm_2:
	la s3,lamar_direita
	j setup3
setup3:		
 	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	la a0,tile_hitbox_char		# Carrega o endereço da hitbox do personagem
	li a3,1				# Seleciona o frame 1
	call print			# imprime o sprite
		
#printando o inimigo e sua hitbox
	la t0,ENEMY_1_SWITCH
	lb t0,0(t0)
	beq t0,zero,setup4
	la t0,ENEMY_1_POS	
	la a0,capacitor_parasita
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	la a0,tile_hitbox_enemy		# Carrega o endereço da hitbox do personagem
	li a3,1				# Seleciona o frame 1
	call print			# imprime o sprite
#definindo a posição de ataque do capacitor parasita
	la t0,CHAR_POS
	lw t1,0(t0)
	la t0,ENEMY_1_ATK
	sw t1,0(t0)
	
setup4:	
 	li s11,0			# Define o valor inicial do registrador da chave
 	j GAME_LOOP
##########
##########
# Quando o registrador s9 atinge o valor estabelecido no game loop,
# é decrementado 1 do valor indicado pela label TEMPO, representando os segundos
#tempo_ataque:

segundo:		
	la t0,TEMPO			# Carregando o valor do tempo atual
	lb t1,0(t0)			
	addi t1,t1,-1			# Decrementa 1 para simbolizar o 1 segundo passado
	sb t1,0(t0)			# Atualiza o tempo
	lb t1,0(t0)			# Carrega o valor do tempo para printar
	mv s9,zero			# Reseta o contador
	li a7,101			# Printa o numero do tempo na tela
	mv a0,t1
	li a1,248
	li a2,56
	li a3,0x37
	ecall
	beq t1,zero,sair
	blt t1,zero,sair
#tempo_ataque:
	la t0,TEMPO_ATK			# Carrega o valor do tempo de ataque do inimigo
	lb t1,0(t0)			
	addi t1,t1,-1			# Decrementa 1 para simbolizar o 1 segundo passado 
	sb t1,0(t0)			# Atualiza o tempo de ataque
	beq t1,zero,inimigo_1		# Se for zero, pula para o ataque ser efetuado
	j GAME_LOOP			
##########
##########
DANO_2:
	la t0,TEMPO			# Carrega o valor do tempo atual
	lb t1,0(t0)
	addi t1,t1,-10			# Decrementa 10 de dano
	sb t1,0(t0)			# Atualiza o valor do tempo
	j GAME_LOOP
##########
##########
CHECK_KEY:
	beq s11,zero,GAME_LOOP
	la t0,SAIDA_POS
	la a0,escotilha_aberta		# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	mv a3,s0			# carrega o valor do frame em a3
	call print
	addi s10,s10,1			# Soma-se 1 ao registrador de selecionar o mapa para indicar que o próxima mapa com sua hitbox deve ser selecionado
	li t1,8				# Soma-se 8 para resetar a posição inicial do personagem e sua hitbox(Supõe-se que a posição inicial do personagem será nas coordenadas (8,8) em todos os mapas por via de simplicidade)
	la t0,CHAR_POS			# Carrega a posição do personagem 
	sh t1,0(t0)			# Atualiza o x
	sh t1,2(t0)			# Atualiza o y
	la t0,OLD_CHAR_POS		# Carrega a posição antiga do personagem
	sh t1,0(t0)			# Atualiza o x
	sh t1,2(t0)			# Atualiza o y
	la t0,TEMPO
	li t1,60
	sw t1,0(t0)
	j SETUP
CHAVE:
	li s11,1			# Altera o valor do registrador da chave
######
#Realiza o processo de atualização de sprites de uma forma meio grosseira a fim de permitir o reuso para todos as direções de movimento	
	la a0,tile_hitbox_char		
	li a3,1
	call print			# imprime o sprite
	
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
######	
	j GAME_LOOP

GAME_LOOP:
#Após as alterações feitas para acomodar a hitbox dinâmica, o game loop está vazio e , acredito eu, poderemos
#usá-lo para fazer o tempo, inimigos e outros processos que devem ocorrer sem o input do jogador

contador:
# Serve para definir quando passou aproximadamente 1 segundo
# este valor de 20 milhões foi escolhido devido a como os comandos são processados no assembly
# e ao fato que a execução no FPGrars é absurdamente rápida. Ele pode ser alterado para mudar
# o quão rápido o tempo é decrementado. Muito provavelmente será alterado quando o resto do jogo
# for programado
	addi s9,s9,1
	li t0,20000000   # Retire 3 zeros caso queira testar dentro do rars normal
	beq s9,t0,segundo
	
inimigo_1:
######
#Checa para ver se o inimigo pode existir
	la t0,ENEMY_1_SWITCH		
	lb t0,0(t0)
	beq t0,zero,game_loop1
######
#Checa para ver se pode atacar	
	la t0,TEMPO_ATK
	lb t1,0(t0)
	bne t1,zero,game_loop1
######
#Reseta o tempo de ataque	
	li t1,1
	sb t1,0(t0)
######
#Atualiza a antiga posição do capacitor		
	la t0,ENEMY_1_POS
	lw t1,0(t0)
	la t0,ENEMY_1_OLD_POS
	sw t1,0(t0)
######
#Atualiza a posição atual do capacitor		
	la t0,ENEMY_1_ATK
	lw t1,0(t0)
	la t0,ENEMY_1_POS
	sw t1,0(t0)
######
#Printa o capacitor na posição de ataque	
	la t0,ENEMY_1_ATK
	
	la a0,capacitor_parasita
	lh a1,0(t0)
	lh a2,2(t0)
	li a3,0
	call print
######
#Checa para ver se o personagem foi atingido
	la t0,CHAR_POS
	lw t0,0(t0)
	la t1,ENEMY_1_ATK
	lw t1,0(t1)
	beq t0,t1,DANO_1
######
#Atualiza a hitbox do inimigo
inimigo1_1:	
	la a0,tile_hitbox_enemy
	li a3,1
	call print
######
#Atualiza a posição de ataque para o próximo ataque		
	la t0,CHAR_POS
	lh t1,0(t0)
	lh t2,2(t0)
	la t0,ENEMY_1_ATK
	sh t1,0(t0)
	sh t2,2(t0)
######
#Limpa o sprite do inimigo e sua hitbox na posição antiga no frame 0 e no frame 1	
	la t0,ENEMY_1_OLD_POS
	la a0,tile
	lh a1,0(t0)
	lh a2,2(t0)
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print
	j game_loop1
######	
DANO_1:
	la t0,TEMPO			# Carrega o valor do tempo atual
	lb t1,0(t0)
	addi t1,t1,-10			# Decrementa 10 de dano
	sb t1,0(t0)			# Atualiza o tempo
######
#Printa a descarga para simbolizar o ataque bem efetuado
	la t0,ENEMY_1_ATK
	la a0,descarga_capacitor	
	lh a1,0(t0)
	lh a2,2(t0)
	li a3,0
	call print
	j inimigo1_1
######								
game_loop1:
#Essa label ficará aqui por possíveis conveniências futuras, mas muito provavelmente pode ser apagada, então dane-se
	call KEY2			# chama o procedimento de entrada do teclado
		
	j GAME_LOOP
##########
##########
### Apenas verifica se há tecla pressionada
KEY2:	li t1,0xFF200000		# carrega o endereco de controle do KDMMIO
	lw t0,0(t1)			# Le bit de Controle Teclado
	andi t0,t0,0x0001		# mascara o bit menos significativo
   	beq t0,zero,FIM   	   	# Se nao ha tecla pressionada entao vai para FIM
  	lw t2,4(t1)  			# le o valor da tecla tecla
	
	li t0,'w'
	beq t2,t0,CHAR_UP		# se tecla pressionada for 'w', chama CHAR_CIMA
	
	li t0,'a'
	beq t2,t0,CHAR_LEFT		# se tecla pressionada for 'a', chama CHAR_CIMA
	
	li t0,'s'
	beq t2,t0,CHAR_DOWN		# se tecla pressionada for 's', chama CHAR_CIMA
	
	li t0,'d'
	beq t2,t0,CHAR_RIGHT		# se tecla pressionada for 'd', chama CHAR_CIMA
	
FIM:	ret				# retorna
##########
##########
CHAR_UP:
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	li t5,320			
	li t6,-1			
	mul t3,t6,t5		
	add t4,t4,t3			# Subtrai-se -1*320 para checar qual a cor do pixel logo acima das coordenadas do jogador
	lb t4,0(t4)			# Carrega um byte do para saber a cor do pixel
	li t5,0xffffffC8		# Checa para ver se é azul/parede
	beq t4,t5,GAME_LOOP
	li t5,0x00000038		# Checa para ver se é verde/porta/escotilha
	beq t4,t5,CHECK_KEY
	li t5,0x00000007
	beq t4,t5,DANO_2
	
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,2(t0)			# salva

#selecionando a sprite
	la t0,CHAR_SELECT
	lw t1,0(t0)
	
  	li t0,'1'
  	beq t1,t0,psngm_1_up
 
  	li t0,'2'
  	beq t1,t0,psngm_2_up
  	 	
  	li t0,'3'
  	beq t1,t0,psngm_2_up
  	
  	li t0,'4'
  	beq t1,t0,psngm_2_up	
	

psngm_1_up:
 	la s3,lamar_cima		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)	
	j up_1
psngm_2_up:
	la s3,lamar_direita
	j up_1	
	
up_1:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)			
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########

	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
	
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_DOWN:
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	li t5,320
	li t6,16
	mul t3,t6,t5
	add t4,t4,t3
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	li t5,0x00000007
	beq t4,t5,DANO_2	
	
	la t0,CHAR_POS
	lh t1,2(t0)			# carrega o y atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,2(t0)			# salva

#selecionando a sprite
	la t0,CHAR_SELECT
	lw t1,0(t0)
	
  	li t0,'1'
  	beq t1,t0,psngm_1_down
 
  	li t0,'2'
  	beq t1,t0,psngm_2_down
  	 	
  	li t0,'3'
  	beq t1,t0,psngm_2_down
  	
  	li t0,'4'
  	beq t1,t0,psngm_2_down	
	

psngm_1_down:
 	la s3,lamar_baixo		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)	
	j down_1
psngm_2_down:
	la s3,lamar_direita
	j down_1	
		
down_1:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_LEFT:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,-1
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	addi t4,t4,-1
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	li t5,0x00000007
	beq t4,t5,DANO_2
		
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,-16			# decrementa 16 pixeis
	sh t1,0(t0)			# salva
	
#selecionando a sprite
	la t0,CHAR_SELECT
	lw t1,0(t0)
	
  	li t0,'1'
  	beq t1,t0,psngm_1_left
 
  	li t0,'2'
  	beq t1,t0,psngm_2_left
  	 	
  	li t0,'3'
  	beq t1,t0,psngm_2_left
  	
  	li t0,'4'
  	beq t1,t0,psngm_2_left	
	

psngm_1_left:
 	la s3,lamar_esquerda		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)	
	j left_1
psngm_2_left:
	la s3,lamar_direita
	j left_1	
		
left_1:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite
	
##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########
CHAR_RIGHT:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	la t1,OLD_CHAR_POS		# carrega em t1 o endereco de OLD_CHAR_POS
	lw t2,0(t0)
	sw t2,0(t1)			# salva a posicao atual do personagem em OLD_CHAR_POS
	
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	mv t3,t6
	addi t3,t3,23
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	#la t4,hitbox_mapateste2
	addi t4,t4,16
	lb t4,0(t4)
	li t5,0xffffffC8
	beq t4,t5,GAME_LOOP
	li t5,0x00000038
	beq t4,t5,CHECK_KEY
	li t5,0x00000007
	beq t4,t5,DANO_2
		
	lh t1,0(t0)			# carrega o x atual do personagem
	addi t1,t1,16			# incrementa 16 pixeis
	sh t1,0(t0)			# salva

#selecionando a sprite
	la t0,CHAR_SELECT
	lw t1,0(t0)
	
  	li t0,'1'
  	beq t1,t0,psngm_1_right
 
  	li t0,'2'
  	beq t1,t0,psngm_2_right
  	 	
  	li t0,'3'
  	beq t1,t0,psngm_2_right
  	
  	li t0,'4'
  	beq t1,t0,psngm_2_right	
	

psngm_1_right:
 	la s3,lamar_direita		# Primeiro sprite do personagem(futuras alterações serão feitas para permitir a seleção de personagem com base no S9)	
	j right_1
psngm_2_right:
	la s3,lamar_direita
	j right_1			
		
right_1:	
	la t0,CHAR_POS			# carrega em t0 o endereco de CHAR_POS
	
	mv a0,s3			# carrega o endereco do sprite 'char' em a0
	lh a1,0(t0)			# carrega a posicao x do personagem em a1
	lh a2,2(t0)			# carrega a posicao y do personagem em a2
	li a3,0				# carrega o valor do frame em a3
	call print			# imprime o sprite

##########
#CHECA_CHAVE:
#O posicionamento desse processo é crucial, pois checa qual a posição do personagem na hitbox antes
#de atualizar a hitbox dele, permitindo saber qual a cor para então fazer o processo desejado, no caso
#a obtenção da chave
	la t0,CHAR_POS
	lh t6,0(t0)
	lh t1,2(t0)			# carrega o y atual do personagem
	
	li t4,0xFF100000		# Carrega o endereço base do frame que se quer printar, sendo FF1 = frame 1 e FF0 = frame 0 (o frame 0 é o que aparece ao jogador)
	li t5,320			
	mul t5,t1,t5	# y * 320	# Multiplica o y por 320
	add t4,t4,t5			# Soma-se o y ao endereço base
	add t4,t4,t6	# a1 += x	# Soma-se o x ao endereço base
	
	lb t4,0(t4)
	li t5,0x00000037
	beq t4,t5,CHAVE	
##########
		
	la a0,tile_hitbox_char
	li a3,1
	call print			# imprime o sprite
			
	la t0,OLD_CHAR_POS		# carrega em t0 o endereco de OLD_CHAR_POS
	
	la a0,tile			# carrega o endereco do sprite 'tile' em a0
	lh a1,0(t0)			# carrega a posicao x antiga do personagem em a1
	lh a2,2(t0)			# carrega a posicao y antiga do personagem em a2
	li a3,0
	call print
	la a0,tile1
	li a3,1
	call print			# imprime o sprite
	
	j GAME_LOOP
##########
##########	
print:
	li t0,0xFF0			# carrega 0xFF0 em t0
	add t0,t0,a3			# adiciona o frame ao FF0 (se o frame for 1 vira FF1, se for 0 fica FF0)
	slli t0,t0,20			# shift de 20 bits pra esquerda (0xFF0 vira 0xFF000000, 0xFF1 vira 0xFF100000)
	
	add t0,t0,a1			# adiciona x ao t0
	
	li t1,320			# t1 = 320
	mul t1,t1,a2			# t1 = 320 * y
	add t0,t0,t1			# adiciona t1 ao t0
	
	addi t1,a0,8			# t1 = a0 + 8
	
	mv t2,zero			# zera t2
	mv t3,zero			# zera t3
	
	lw t4,0(a0)			# carrega a largura em t4
	lw t5,4(a0)			# carrega a altura em t5
	
	
PRINT_LINHA:
	lw t6,0(t1)			# carrega em t6 uma word (4 pixeis) da imagem
	sw t6,0(t0)			# imprime no bitmap a word (4 pixeis) da imagem
	
	addi t0,t0,4			# incrementa endereco do bitmap
	addi t1,t1,4			# incrementa endereco da imagem
	
	addi t3,t3,4			# incrementa contador de coluna
	blt t3,t4,PRINT_LINHA		# se contador da coluna < largura, continue imprimindo

	addi t0,t0,320			# t0 += 320
	sub t0,t0,t4			# t0 -= largura da imagem
	# ^ isso serve pra "pular" de linha no bitmap display
	
	mv t3,zero			# zera t3 (contador de coluna)
	addi t2,t2,1			# incrementa contador de linha
	bgt t5,t2,PRINT_LINHA		# se altura > contador de linha, continue imprimindo
	
	ret				# retorna

sair:
	li a7,10
	ecall

.include "SYSTEMv21.s"
